package com.github.victorrentea.livecoding.lombok

import com.github.victorrentea.livecoding.FrameworkDetector.lombokIsPresent
import com.github.victorrentea.livecoding.FrameworkDetector.slf4jIsPresent
import com.intellij.codeInspection.LocalInspectionTool
import com.intellij.codeInspection.LocalQuickFixOnPsiElement
import com.intellij.codeInspection.ProblemHighlightType
import com.intellij.codeInspection.ProblemsHolder
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.command.WriteCommandAction
import com.intellij.openapi.diagnostic.logger
import com.intellij.openapi.project.Project
import com.intellij.psi.*
import com.intellij.psi.codeStyle.JavaCodeStyleManager
import com.intellij.psi.util.PsiTreeUtil


class ReplaceWithSlf4jInspection : LocalInspectionTool() {
    companion object {
        val log = logger<ReplaceWithSlf4jInspection>()
        const val INSPECTION_NAME = "Logger definition can be generated by Lombok"
        const val FIX_NAME = "Replace with @Slf4j (lombok)"
    }

    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
        if (!lombokIsPresent(holder.file) || !slf4jIsPresent(holder.file)) {
            return PsiElementVisitor.EMPTY_VISITOR
        }
        return ReplaceWithSlf4jVisitor(holder)
    }

    class ReplaceWithSlf4jVisitor(private val holder: ProblemsHolder) : PsiElementVisitor() {
        override fun visitElement(field: PsiElement) {
            super.visitElement(field)
            if (field !is PsiField) return
            if (
                field.name == "log" &&
                field.hasModifierProperty(PsiModifier.STATIC) &&
                field.hasModifierProperty(PsiModifier.FINAL) &&
                field.type.equalsToText("org.slf4j.Logger")
                ) {
                val assignedToExpr = field.initializer as? PsiMethodCallExpression ?: return
                val psiMethod = assignedToExpr.methodExpression.resolve() as? PsiMethod ?: return
                if (psiMethod.name != "getLogger") return
                if (psiMethod.containingClass?.qualifiedName != "org.slf4j.LoggerFactory") return
                val argument = assignedToExpr.argumentList.expressions.singleOrNull() as? PsiClassObjectAccessExpression ?: return
                if (!argument.operand.type.equalsToText(field.containingClass?.qualifiedName?:"/")) return
//                if (argument != field.containingClass?.name + ".class") return

                holder.registerProblem(
                    field.nameIdentifier,
                    INSPECTION_NAME,
                    ProblemHighlightType.WEAK_WARNING,
                    ReplaceWithSlf4jFix(field))
            }
        }
    }

    class ReplaceWithSlf4jFix(psiField: PsiField) : LocalQuickFixOnPsiElement(psiField) {
        override fun getFamilyName() = "Live-Coding"

        override fun getText() = FIX_NAME

        override fun invoke(project: Project, file: PsiFile, psiField: PsiElement, endElement: PsiElement) {
            val parentClass = PsiTreeUtil.getParentOfType(psiField, PsiClass::class.java) ?: return
            val modifiers = parentClass.modifierList ?: return

            ApplicationManager.getApplication().invokeLater {
                WriteCommandAction.runWriteCommandAction(project, FIX_NAME, "Live-Coding", {
                    val annotation = modifiers.addAnnotation("lombok.extern.slf4j.Slf4j")
                    JavaCodeStyleManager.getInstance(project).shortenClassReferences(annotation)

                    psiField.delete()
                })
            }
        }

    }
}



